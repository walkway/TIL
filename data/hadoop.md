# Hadoop
- High-Availability Distributed Object-Oriented Platform
- 간단한 프로그래밍 모델을 사용하여 컴퓨터 클러스터 전체에서 대용량 데이터 세트의 분산 처리를 허용하는 프레임워크
- 단일 서버에서 각각 로컬 계산 및 스토리지를 제공하는 수천 대의 시스템으로 확장하도록 설계
- 고가용성을 제공하기 위해 하드웨어에 의존하는 대신 라이브러리 자체는 애플리케이션 계층에서 오류를 감지하고 처리하도록 설계되어 각각 오류가 발생하기 쉬운 컴퓨터 클러스터 위에 고가용성 서비스를 제공
- Hadoop Common: 다른 Hadoop 모듈을 지원하는 공통 유틸리티
- HDFS(Hadoop Distributed File System): 애플리케이션 데이터에 대한 높은 처리량 액세스를 제공하는 분산 파일 시스템
- Hadoop YARN: 작업 스케줄링 및 클러스터 리소스 관리를 위한 프레임워크
- Hadoop MapReduce: 대용량 데이터 세트의 병렬 처리를 위한 YARN 기반 시스템
- https://hadoop.apache.org/

## HDFS
- 다양한 구조적 및 비구조적 데이터 노드에 걸쳐 대량의 데이터 세트 관리
- 기본적으로 데이터를 64MB 블록 단위로 나누어 저장, 단일 디스크 보다 큰 파일도 저장
  - 블록단위가 256MB라면 1G파일은 4개의 블록으로 나누어 저장
  - 블록이 큰 이유는 탐색 비용을 최소화하기 위함
  - HDFS 모든 파일, 디렉터리, 블록 정보와 같은 파일 시스템 이미지는 네임노드에서 인메모리 형식으로 관리, 크기가 작은 파일을 많이 저장하면 메모리에서 처리할 수 있는 파일이 64MB 이상 파일을 사용할 때보다 더 빠른 속도로 줄어듬
- 각 블록을 복제하여 저장
  - 하나의 블록은 3개의 블록으로 복제되어 저장 -> ex) 1G 데이터를 저장할 때 3G 저장 공간 필요
- 데이터 지역성(Block Locality): 데이터의 위치에서 처리하여 데이터를 이동시키는 비용 절감
- 마스터/슬레이브(master/slave) 구조
  - HDFS 클러스터는 하나의 네임노드와 파일 시스템을 관리하고 클라이언트의 접근을 통제하는 마스터 서버로 구성
- 저장한 데이터는 수정할 수 없고, 읽기만 가능해서 데이터 무결성을 유지

### 네임노드, 데이터노드
- 네임노드 = 마스터, HDFS 모든 메타데이터 관리, 클라이언트가 HDFS 저장된 파일에 접근할 수 있게 함
- 데이터노드 = 슬레이브, 여러 대의 데이터 노드에 분산 저장
- 데이터노드는 주기적으로 네임노드에게 하트비트와 블록 목록이 저장된 블록 리포트를 보냄
- 네임노드는 하트비트를 통해 데이터노드가 정상 작동하는지 확인
- 네임노드는 블록 리프토를 통해 데이터 노드의 모든 블록을 확인하고, 파이릐 복제본 위치 결정
- 클라이언트는 네임노드에 접속해 원하는 파일이 저장된 블록 위치를 조회하고 해당 블록이 저장된 데이터노드에서 직접 조회

## 맵리듀스
- 맵: (k1, v1) -> list(k2, v2)
- 리듀스: (k2, list(v2)) -> list(k3, v3)
- 데이터에 대한 분산과 병렬 처리를 프레임워크가 전담

### 클라이언트
- 사용자가 실행한 맵리듀스 프로그램과 하둡에서 제공하는 맵리듀스 API를 의미
- 개발한 프로그램을 하둡에서 실행

### 잡트래커
- 클라이언트가 하둡으로 실행을 요청하는 맵리듀스 프로그램은 잡이라는 작업단위로 관리
- 하둡 클러스터에 등록된 전체 잡 스케줄링 관리, 모니터링
- 전체 하둡 클러스터에서 하나의 잡트래커가 실행되고, 보통 하둡 네임노드 서버에서 실행(필수는 아님)
- 사용자가 잡을 욫어하면 잡트래커는 잡을 처리하기 위해 몇개의 맵/리듀스를 실행할 지 계산 -> 계산된 맵/리듀스를 어떤 태스크트래커에서 실행할지 결정 -> 해당 태스크 트래커에 잡 할당

### 태스트트래커
- 사용자가 설정한 맵리듀스 프로그램을 실행하며, 하둡의 데이터노드에서 실행되는 데몬
- 맵 태스크와 리듀스 태스크가 생성되면 새로운 JVM 구동하여 태스크 실행

# HBase
- Apache Hadoop 에코시스템에 있는 확장성이 뛰어난 분산 빅 데이터 스토어
- 하둡 분산 파일 시스템(HDFS) 위에서 실행되는 버전이 지정된 비관계형 오픈 소스 데이터베이스이며, 수십억 개의 행과 수백만 개의 열로 구성된 테이블에 일관된 실시간 임의 액세스를 제공하도록 구축
- HBase는 sparse matrix(희소행렬)방식으로 데이터를 저장(모든 필드에 값을 채울 필요가 없음)
- Column Oriented : RDBMS는 row 단위로 데이터를 저장하지만 HBase는 Sparse하기 때문에, 컬럼 단위로 데이터를 읽고 쓸 수 있음
- Distributed: 테이블은 수백만개의 Row와 컬럼들로 구성되어 분산 할 수 있음
- versioned: 하나의 row key에 여러 개의 row를 저장 할 수 있음. Timestamp가 버전이 되며, 질의를 할 경우 가장 최근 timestamp의 row를 읽음

## Data Model
- 데이터는 행과 열이 있는 테이블에 저장
- 관계형 데이터베이스(RDBMS)와 겹치는 용어이지만 유용한 비유는 아님, HBase 테이블을 다차원 맵으로 생각하는 것 도움이 됨

### Table
- 여러 Row 저장
- Column Oriented 형태 저장

### Row
- 하나의 Row Key와 여러개의 Column으로 구성
- Row들은 이름순으로 정렬되어 저장

### Column
- Column Family와 Column Qualifier로 구성
- 구분자 : 사용

### Column Families
- 성능상의 이유로 여러 Column들을 물리적으로 가깝게 저장
- 테이블 내 각 Row는 같은 Column Families를 가짐
- 주어진 Row는 주어진 Column Families에 아무 것도 저장하지 않을 수 있음
- 각 Column Families에는 해당 값을 메모리에 캐시해야 하는지 여부, 데이터를 압축하는 방법 또는 행 키를 인코딩하는 방법 등과 같은 스토리지 속성 집합이 있음

### Column Qualifiers
- index를 위해 Column Family에 추가
- 테이블이 생성될때 Column Family가 고정적이더라도, Column Qualifiers는 유동적으로 다룰 수 있음

## ACID
- HBase는 ACID를 준수하는 데이터베이스가 아니다.
- 시스템과 상호작용하는 애플리케이션의 거동에 대해 일부를 보장한다.
- 작업은 저수준의 원자적으로 동작한다. 주어진 로우에 대한 put 메서드는 전체가 완벽한 성공과 실패 중 하나가 되고 실패가 되면 작업이 시작되기 전의 상태로 남아있다.
- 내부 로우 작업은 원자적이지 않다. 모든 작업이 모두 완료되거나 실패하거나에 대한 보장이 없다.
- 주어진 로우에 대한 다중 쓰기 작업은 그들 내에서는 항상 서로 독립적이다.

## HBase Crash Recovery
- 리전서버가 실패하면, 실패를 감지하고 복구하기 전까지는 해당 리전을 사용 할 수 없다.
- 주키퍼는 리전 서버에 주기적으로 허트비트(Heat beats)메시지에 대한 응답을 확인한다. 리전 서버가 허트비트 요청에 대한 응답을 하지 않은 경우 노드가 실패했다고 판단한다. HMaster는 리전서버가 실패했다는 통지를 받게된다.
- 리전서버 실패를 감지한 HMaster는 충돌한 리전을 작동중인 다른 리전서버에 할당한다. 
- Memstore에서 디스크로 flus되지 않은 데이터는 복제된 WAL 데이터를 이용해서 복구한다. HMaster는 복제된 WAL 데이터를 별도의 파일로 분할하고, 이 파일을 새로 할당한 리전서버의 데이터노드에 저장한다. 각 리전서버는 데이터노드에 저장된 WAL 파일로 부터 WAL을 재생해서 Memstore를 재구성 한다.
