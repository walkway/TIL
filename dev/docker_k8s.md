# 도커 

- 기존 가상화 기술은 하이퍼바이저를 이용, 여러 운영체제를 하나의 호스트에서 생성하고 사용하는 방식 > 가상 머신
- 하이퍼 바이저에 의해 생성되고 관리되는 운영체제 -> 게스트 운영체제
  - 시스템 자원을 가상화하고 독립된 공간 생성 작업은 하이퍼바이저를 거치기 때문에 일반 호스트에 비해 성능 손실
  - 가상 머신 이미지를 애플리케이션으로 배포하기 부담스러움
- 도커 컨테이너는 가상 공간 생성을 위해 리눅스 자체 기능 chroot, 네임스페이스, cgroup 사용
  - 프로세스 단위 격리 환경, 성능 손실 거의 없음
- 도커 이미지: 여러 계층으로 된 바이너리 파일로 존재, 읽기 전용
- 도커 컨테이너: 이미지로 컨테이너를 생성하면, 이미지 목적에 맞는 파일이 들어 있는 파일 시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생성

### 애플리케이션 개발, 배포 편의성
- 도커 컨테이너는 호스트 OS 위에서 실행되는 격리된 공간, 컨테이너 자체에 특별한 권한을 주지 않는 한 호스트 OS에 영향을 주지 않음
- 터널을 포함하지 않아서 이미지 크기가 크지 않음
- 중복 레이어를 재사용할 수 있음

# 쿠버네티스
### 쿠버네티스는 v1.20 이후 컨테이너 런타임으로 도커 사용 중단
- 기본(underlying) 런타임 중 하나인 도커는 쿠버네티스의 컨테이너 런타임 인터페이스(CRI)를 사용하는 런타임으로써는 더 이상 사용되지 않음(deprecated)
  - kubernetes에서 dockershim 변환하는데 비효율적이라고 판단
- 도커가 생성한 이미지는 모든 런타임을 통해 클러스터에서 계속 작동
- https://kubernetes.io/ko/blog/2020/12/02/dont-panic-kubernetes-and-docker/

### Container Runtime
- OCI(Open Container Initiative): 컨테이너 런타임에 대한 표준으로 컨테이너를 실행하기 위한 저수준 런타임
- CRI(Container Runtime Interface): 쿠버네티스에서 제공하는 컨테이너 런타임 추상화 계층
- 저수준 런타임: namespace와 cgroup을 이용해서 컨테이너 자체를 만듬, 이미지로부터 컨테이너를 실행하는 기능 없음, runc
- 고수준 런타임: 저수준 런타임 위에 배치되어 이미지로부터 컨테이너 실행 가능, containerd, cri-o
