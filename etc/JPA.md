# JPA

- java ORM 기술 API 표준 명세
  - ORM: 객체와 관계형 데이터베이스를 매핑하는 방법, ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 해결한다.

## 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 생성하면 영속성 컨텍스트가 자동으로 생성되고, Entity Manager를 이용해서 영속성 컨텍스트에 엔티티를 보관/관리한다.
- 비영속: 영속성 컨텍스트와 전혀 무관한 상태로 순수한 객체의 상태 (처음 객체가 생성되면 비영속 상태)
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에서 관리하다 영속성 컨텍스에서 분리된 상태, 준영속 상태는 영속 상태 였던 적이 있기 때문에 @Id 값을 가지고 있다. 하지만, 비영속은 순수한 객체의 상태이기 때문에 @Id 값을 안 가지고 있는 경우가 존재할 수 있다.
- 삭제: 삭제된 상태

### 1차 캐시
- 영속성 컨택스트 내부에는 1차 캐시라고 불리는 캐시를 가지고 있다. 영속상태의 엔티티는 모두 1차 캐시에 저장되고, 1차 캐시는 @Id를 키로 가지고 있는 Map이 존재한다. 1차 캐시를 이용하면 데이터의 결과를 빠르게 얻을 수 있는 장점을 가지고 있다. member 엔티티를 조회할 때, 바로 데이터베이스에서 직접 조회하는 것이 아니고, 우선적으로 1차 캐시에 member 엔티티가 있는지 @Id값으로 확인을 한 후에 엔티티가 있을 떄는 1차 캐시에서 엔티티가 없을 때는 데이터베이스에서 조회를 한 후, 1차 캐시에 저장하고, 1차 캐시에서 엔티티를 전달한다. 
- 1차캐시를 우선으로 확인하고, 데이터베이스를 조회한다.

### 동일성 보장
- 엔티티를 조회할 때, 1차 캐시에서 모든 엔티티를 가져온다. 모든 엔티티는 최종적으로 1차 캐시에서 가져오므로 식별자가 동일한 엔티티는 동일성 보장된다.

### 트랜잭션을 지원하는 쓰기지연
- 트랜잭션은 데이터베이스에서 하나의 작업단위를 의미한다. 영속성 컨텍스트는 삽입/삭제/수정과 같은 DML이 발생했을 때, 바로 데이터베이스에 반영하지 않고, 트랜잭션을 커밋할 때, 모아둔 쿼리들을 한번에 데이터베이스 반영을 한다. 이것이 쓰기 지연이다. 쿼리들은 영속성 컨텍스트의 쓰기지연SQL 저장소에 저장된다. 커밋을 실행 하면, flush -> commit 순서로 데이터베이스에 작업한다. flush는 쓰기지연SQL 저장소 쿼리들을 데이터베이스에 저장하는 것이고, commit은 데이터베이스에 쿼리들을 반영하는 것을 의미한다. 
- 쓰기지연을 하면, 데이터베이스에 접근하는 횟수가 줄기 때문에 성능면에서 뛰어나다.

### 변경 감지
- 영속성 컨텍스트의 1차캐시에는 스냅샷을 통해 엔티티의 변경을 감지한다. 쿼리를 통해 데이터를 조작하는 방법외에도 영속상태의 엔티티의 상태를 변경하는 방법으로도 데이터베이스의 데이터를 변경할 수 있다. 변경감지는 아래와 같은 순서로 동작한다.
````
a. 트랜잭션을 커밋하면, flush 가 호출되고, 엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.
b. 변경된 엔티티가 존재하면, update 쿼리를 생성해서 쓰기지연SQL 저장소에 저장한다.
c. 쓰기지연SQL 저장소에 생성된 쿼리들을 데이터베이스에 flush하고 commit 한다.
````
- 변경감지는 오직 영속 상태의 엔티티에만 적용이 된다. 비영속과 준영속은 해당되지 않는다. JPA에서 엔티티의 특정 필드가 변경되었을 때, 특정 필드만 update 하는 쿼리를 만드는 것이 아닌, 모든 필드를 업데이트 하는 쿼리를 만든다.