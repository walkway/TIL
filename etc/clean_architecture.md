# Clean Architecture
- 클린 아키텍처는 우리 주변의 모든 불확실성을 고려하여 유지 관리가 용이한 코드에 대한 지침이다.

### 관심사 분리
- 프레임워크 독립적: 아키텍처는 소프트웨어 라이브러리 존재에 의존하지 않는다. 
- 테스트 용이함: 비즈니스 규칙은 UI, 데이터베이스, 웹 서버, 기타 외부 요인없이 테스트 가능해야 한다.
- UI 독립적: 시스템의 나머지 부분을 변경할 필요 없이 UI를 쉽게 변경할 수 있다.
- 데이터베이스 독립적:  비즈니스 규칙은 데이터베이스에 의존하지 않는다. (Oracle 또는 SQL Server를 Mongo, BigTable, CouchDB 또는 다른 것으로 교체)
- 외부 기능 독립적: 실제로 비즈니스 규칙은 외부 세계에 대해 모른다.

### Dependency 규칙
- 동심원은 소프트웨어의 각각의 영역이다.
- 내부(Policy) -> 외부(Mechanism) 외부 원으로 향할 수도록 고수준 소프트웨어이다.
- 의존성은 내부 원을 향한다. 내부 원은 외부 원에 대해 알지 못한다.
  - 외부 원에서 선언한 이름을 내부 원에서 참조하면 안된다.
  - 외부 원에서 사용하는 데이터 포맷은 내부 원에서 사용하지 않는다.
- 내부로 이동함에 따라 추상화 수준은 높아진다. 외부 원은 저수준의 구체적인 상세 정보를 담는다. 
- 내부 원으로 이동해가면서 소프트웨어는 추상화 되고, 고수준의 정책을 캡슐화한다. 가장 내부에 있는 원이 가장 일반적이다.

### Entities
- Enterprise wide 비즈니스 규칙을 캡슐화한다.
- 기능이 있는 객체, 데이터 구조 함수 집합이다.
- 외부에서 무언가 변경될 때, 변경될 가능성이 가장 적은 계층이다.
  - ex) 보안 변경에 의해 영향을 받는 개체로 예상하지 않고, 운영상 변경이 Entity 계층에 영향을 주면 안된다.
- Entity는 다른 계층을 알 수 없고, 어떤 것에도 의존하지 않는다.
- 비즈니스가 복잡하다면 도메인 코드를 최대한 명확하게 구축해야 한다.

### Use Cases
- 비즈니스 고유 규칙
- Entity로 부터의 혹은 Entity에서의 데이터 흐름을 조합한다.
- 계층의 변경이 Entity에 영향을 주지 않는다. 데이터베이스, UI 또는 공통의 프레임워크의 변경으로부터 영향 받지 않는다.
- Use Case 의 상세가 바뀐다면 이 계층의 코드는 영향을 받는다.
````
    Gather Info for New Loan
    
    Input:  Name, Address, Birthdate, etc.
    Output: Same info + credit score
    
    Rules:
      1. Validate name
      2. Validate address, etc.
      3. Get credit score
      4. If credit score < 500 activate Denial
      5. Else create Customer (entity) and activate Loan Estimation
````

### Interface Adapters
- Use Case와 Entity에 용이한 형식으로부터 데이터베이스나 웹 등 외부의 기능에 용이한 형식으로 데이터를 변환한다. (Presenters, Views, Controllers)
- 모델이 Controllers에서 Use Case로 전달되고,Use Case에서 Presenters, Views로 되돌아가는 단순한 데이터 구조일 가능성이 높다.
- 이 계층에서 데이터는, Entity나 Use Case에 용이한 형에서, 사용하고 있는 프레임워크에 용이한 형으로 변환된다. 

### Frameworks and Drivers / Infrastructure
- 가장 외부 계층은 데이터베이스나 웹 프레임워크 등 일반적으로 프레임워크나 도구로 구성된다. 
- 이 계층에는 내부의 원과 통신할 연결 코드 이외에는 별다른 코드를 작성하지 않는다.

### 매핑
- 경계 간 매핑
  - 찬성: 계층간 매핑하지 않고 같은 모델을 사용한다면, 두 계층은 강하게 결합된다.
  - 반대: Boilerplate code 가 많아진다.
- 매핑하지 않는 전략: 하나의 모델 사용
  - 장점: 모든 계층이 같은 모델을 사용하여, 계층 간 매핑을 할 필요없다.
  - 문제: 웹 계층, 영속성 계층의 변경에 따라 도메인이 변경될 수 있다. ORM을 위한 Annotation을 추가하는 등 (단일 책임 원칙 위반)
  - 모든 계층이 정확히 같은 구조, 같은 정보를 필요할 때 효과적이다.
- 양방향 매핑 전략: 계층 별 전용 모델 사용
  - ex) 웹 계층에서 웹 모델을 인커밍 포트에서 필요한 모델로 매핑 / 인커핑 포트에서 반환된 도메인 객체는 다시 웹모델로 매핑
  - 장점: 웹, 영속성 관심사로 오염되지 않는다.
  - 문제: Boilerplate code, 도메인 모델이 경계를 넘어 통신하는데 사용된다.
- 완전 매핑 전략
  - 장점: 각 작업에 특화한 모델을 사용한다. (Command, Request)
  - 문제: 많은 코드
  - in 어댑터와 어플리케이션 계층 사이 상태 변경 유스케이스 경계를 명확하게 사용할 때
- 단방향 매핑 전략
  - 모든 계층의 모델이 같은 인터페이스를 구현
  - 장점: 매핑 책임이 명확
  - 문제: 매핑 계층이 퍼져있어, 개념적으로 어렵다
  - 계층 간 모델이 비슷할 때 효과적이다.

### 인터페이스 관련 의견
````
// 켄트 백 구현패턴
인터페이스 추가에는 비용이 발생한다. 인터페이스를 사용하게 되면 우리는 인터페이스를 배우고 이해하며 문서화하고 디버깅하고 정리하고 조회해서 적당한 이름을 지어야 한다. 인터페이스 수를 최대한 늘린다고 해서 소프트웨어 비용이 최소화되는 것은 아니다. 따라서 인터페이스를 통해 유연성을 얻을 수 있는 경우에만 인터페이스에 비용을 지불해야 한다.
인터페이스를 사용하게 된 경제적 이유로는 소프트웨어는 예측하기 어렵다는 점을 들 수 있다.
소프트웨어는 유연해야 하지만 유연성에는 비용이 들고, 어떤 부분에서 유연성이 필요할지 예측하기란 쉽지 않다. 따라서 실제 필요해지는 경우에만 시스템의 유연성을 부여하자는 결론에 이른다. 유연성을 부여하려면 기존 코드를 수정해야 하기 때문에 비용이 발생한다. 만약 소프트웨어 수정을 혼자 감당할 수 없다면, 비용은 더욱 커진다.
````

### Domain Driven Design
- 도메인과 일치하도록 소프트웨어를 모델링하는 데 중점을 둔 소프트웨어 설계 접근 방식
 - 도메인: 소프트웨어로 해결해야할 문제의 영역, 한 조직이 행하는 일과 그 조직 안의 세계를 의미
- 소프트웨어 코드의 구조와 언어(클래스 이름, 클래스 메소드, 클래스 변수)가 비즈니스 도메인의 용어를 일치시켜 나간다는 점
- 계속해서 발전하는 모델의 구현에 초점
- 핵심 도메인 및 도메인 논리에 프로젝트의 주요 초점
- 도메인 모델에 기반한 복잡한 디자인
- 특정 도메인의 개념적 모델을 계속해서 개선하기 위해 기술 전문가와 도메인 전문가 간의 협력 필요
- 도메인 모델 패턴
  - 도메인 객체가 속성뿐만 아니라 비즈니스 행위를 가지고 있어 책임을 수행
  - 서비스의 책임들이 도메인으로 분산되기 때문에 서비스의 메서드는 단순함
  - 적절한 책임을 가진 여러 클래스로 구성되므로 이해하기 쉽고 관리 및 테스트하기 수월

https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
https://pusher.com/tutorials/clean-architecture-introduction/
https://www.baeldung.com/spring-boot-clean-architecture

